#!/usr/bin/env bash
currentDir=$(pwd)
separator=$'\x3B'
clear
#================================================================
#region Functions

Exit(){
    cd "$currentDir"
    exit 1
}

Print(){
    echo -e "\033[0;34mInfo\033[0m: $1"
}

PrintError(){
    echo -e "\033[0;31mError\033[0m: $1"
}

#endregion

#================================================================
#region Repository

#check if repo exists
repoDir="$HOME"/.config/git-mirror_tracker/
if [ ! -d "$repoDir".git  ]; then
    Print "Initializing git-mirror_tracker repository at $repoDir"
    mkdir -p "$repoDir"
    git init "$repoDir"
fi

#----------------------------------------------------------------
#Functions

RepoUpdate(){   #fileName #config
    Print "Saving local config for $1"
    echo "$2" > "$repoDir$1"
}

RepoCommit(){
    cd "$repoDir"
    #check changes
    if [ -z "$(git status --porcelain)" ]; then
        Print "Repo has no changes"
        return
    else
        Print "Repo has changes"
        git status
    fi
    #commit
    commitCount="$(git rev-list --count HEAD)"
    if [ -z $commitCount ]; then
        commitName="First Commit"
    else
        commitName="Update $commitCount"
    fi
    Print "Commiting \"$commitName\""
    git add *
    git commit -m "$commitName"
}

RepoStage(){
    cd "$repoDir"
    git add *
}

#endregion

#================================================================
#Listing Management

# repoName      #the true id
# repoID = git rev-list --max-parents=0 HEAD
# repoPath

Mark(){ #repoPath #repoName
    #correct argument
    repoPath="$1"
    if [ -z "$repoPath" ]; then
        repoPath="$currentDir"
    fi
    repoPath="$(realpath "$repoPath")"

    #skip if repoPath is not a dir
    if [ ! -d "$repoPath" ]; then
        return
    fi
    #skip if git doesn't exists
    if [ ! -d "$repoPath/.git" ]; then
        return
    fi

    #signal
    Print "Checking $repoPath"

    #get repoID
    repoId=$(git -C "$repoPath" rev-list --max-parents=0 HEAD)
    
    #correct name
    repoName="$2"
    if [ -z "$repoName" ]; then
        read -p "Name for $repoPath (default: $(basename "$repoPath")):" repoName
        if [ -z "$repoName" ]; then
            repoName=$(basename "$repoPath")
        fi
    fi

    #construct row
    row="${repoName}${separator}${repoPath}${separator}${repoId}"

    #check if repo with such name and path has already been listed
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        #check
        if [ "$repoName" = "$row_repoName" ]; then
            PrintError "Repository named \"$repoName\" already exists"
            return
        elif [ "$repoPath" = "$row_repoPath" ]; then
            PrintError "Repository named \"$row_repoName\" already tracks $repoPath"
            return
        fi
    done < "$repoDir/repolist"
    echo "$row" >> "$repoDir/repolist"
    Print "Tracking \"$repoName\" at $repoPath"
}

# no update if the dir doesn't exist anymore
Update(){
    #check baseDir
    if [ -z "$1" ]; then
        baseDir="$HOME"
    else
        baseDir="$1"
    fi

    #search
    for dir in "$baseDir"/*; do
        if [ -d "$dir/.git" ]; then
            #echo "Git repository found: $dir"
            #scope
            cd "$dir"
            #git config --local --list
            RepoUpdate "${dir:${#baseDir} + 1}" "$(git config --local --list)"
            #echo $(git remote -v)
        fi
    done

    #stage
    RepoStage
}

#================================================================
#region Commands

case "$1" in
    #------------------------------------------------------------
    log)
        cd "$repoDir"
        git log
        ;;
    status)
        cd "$repoDir"
        git status
        ;;
    commit)
        RepoCommit
        ;;
    stage)
        Update
        ;;
    reset)
        cd "$repoDir"
        git reset --hard
        ;;
    #------------------------------------------------------------
    mark)
        shift
        while [ $# -gt 0 ]; do
            Mark "$1"
            shift
        done
        ;;
    demark)

        ;;
    list)
        ;;
    #------------------------------------------------------------
    export)
        ;;
    import)
        ;;
    #------------------------------------------------------------
    update)
        Update
        #RepoCommit
        ;;
    fetch)
        ;;
    #------------------------------------------------------------
    *)
        Print "No command"
        ;;
esac

#endregion

#================================================================
#region Exit

Exit

#endregion