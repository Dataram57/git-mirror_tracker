#!/usr/bin/env bash
currentDir=$(pwd)
separator=$'\x3B'

#================================================================
#region Functions

Exit(){
    cd "$currentDir"
    exit 1
}

Print(){
    echo -e "\033[0;34mInfo\033[0m: $1"
}

PrintError(){
    echo -e "\033[0;31mError\033[0m: $1"
}

PrintSuccess(){
    echo -e "\033[0;32mSucess\033[0m: $1"
}

PrintWarning(){
    echo -e "\033[0;33mWarning\033[0m: $1"
}

#endregion

#================================================================
#region Repository

#check if repo exists
repoDir="$HOME"/.config/git-mirror_tracker/
if [ ! -d "$repoDir".git  ]; then
    Print "Initializing git-mirror_tracker repository at $repoDir"
    mkdir -p "$repoDir"
    git init "$repoDir"
fi

#----------------------------------------------------------------
#Functions

RepoWrite(){   #fileName #config
    mkdir -p "$(dirname "$repoDir$1")"
    echo "$2" > "$repoDir$1"
}

RepoCleanChanges(){
    cd "$repoDir"
    git restore . && git clean -fd
    cd "$currentDir"
}

RepoCommit(){
    cd "$repoDir"
    #check changes
    if [ -z "$(git status --porcelain)" ]; then
        Print "Repo has no changes"
        return
    else
        Print "Repo has changes"
        git status
    fi
    #commit
    commitCount="$(git rev-list --count HEAD)"
    if [ -z $commitCount ]; then
        commitName="First Commit"
    else
        commitName="Update $commitCount"
    fi
    Print "Commiting \"$commitName\""
    git add *
    git commit -m "$commitName"
}

RepoStage(){
    cd "$repoDir"
    git add *
    PrintSuccess "Changes have been staged."
    cd "$currentDir"
}

GetRepoId(){
    git -C "$1" rev-list --max-parents=0 HEAD | tail -n 1
}

#endregion

#================================================================
#Listing Management

#check if repolist file exists
repoDir="$HOME"/.config/git-mirror_tracker/
if [ ! -f "$repoDir"repolist ]; then
    Print "Creating repolist file"
    touch "$repoDir"repolist
fi

#----------------------------------------------------------------
#Functions

# repoName      #the true id
# repoID = git rev-list --max-parents=0 HEAD
# repoPath

Mark(){ #repoPath
    #repair repolist 
    RepoCleanChanges

    #correct argument
    repoPath="$1"
    if [ -z "$repoPath" ]; then
        repoPath="$currentDir"
    fi
    repoPath="$(realpath "$repoPath")"

    #skip if repoPath is not a dir
    if [ ! -d "$repoPath" ]; then
        return
    fi
    #skip if git doesn't exists
    if [ ! -d "$repoPath/.git" ]; then
        return
    fi

    #get repoID
    repoId=$(GetRepoId "$repoPath")

    #signal
    Print "Checking $repoPath"

    #check if repo with such path and repoId has already been listed
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        #check
        if [ "$repoPath" = "$row_repoPath" ]; then
            if [ "$repoId" = "$row_repoId" ]; then
                Print "Repository named \"$row_repoName\" already tracks "$repoPath" with \""$repoId"\" as repoId."
                return
            fi
        fi
    done < "$repoDir/repolist"

    #insert with proper name
    repoName=""
    while [ -z "$repoName" ]; do
        #get name
        read -p "Name for $repoPath (default: $(basename "$repoPath")):" repoName
        if [ -z "$repoName" ]; then
            repoName=$(basename "$repoPath")
        fi

        #check if repo with such name has already been listed
        while IFS= read -r line; do
            IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
            #check
            if [ "$repoName" = "$row_repoName" ]; then
                PrintError "Repository named \"$repoName\" already exists"
                repoName=""
                break
            fi
        done < "$repoDir/repolist"
    done

    #Insert new entry
    echo "${repoName}${separator}${repoPath}${separator}${repoId}" >> "$repoDir/repolist"
    PrintSuccess "Tracking \"$repoName\" at $repoPath."

    #stage repolist
    RepoStage
}

DeMark(){ #RepoName
    #clean changes
    RepoCleanChanges

    #check if repo with such path and repoId has already been listed
    i=$((1))
    f=""
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        #check
        if [ "$1" = "$row_repoName" ]; then
            f=$((i))
            break
        fi
        i=$((i+1))
    done < "$repoDir/repolist"

    #remove if found
    if [ ! -z "$f" ]; then
        #remove line and stage
        sed -i ""$f"d" "$repoDir/repolist"
        PrintSuccess "Demarked \""$1"\"."
        RepoStage
    else
        PrintError "No such repository marked as \""$1"\""
    fi
}

List(){
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        echo -e "\033[0;32m"$row_repoName"\033[0m - $row_repoPath"
    done < "$repoDir/repolist"
}

Update(){
    #Clean untracked mess
    RepoCleanChanges

    #visit each marked repo
    #this method will perform overwrites if there are more than 1 same row_repoPaths.
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        #get repo vars
        repoName="$row_repoName" 
        repoPath="$row_repoPath"
        #check if there is no git repo at repoPath
        if [ ! -d "$repoPath/.git" ]; then
            continue
        fi
        repoId=$(GetRepoId "$repoPath")
        #repo_* vars will now chagne

        #check if there exists an entry that has the same repoPath and repoId
        while IFS= read -r line; do
            IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
            #check if found the same case
            if [ "$repoPath" = "$row_repoPath" ]; then
                if [ "$repoId" = "$row_repoId" ]; then
                    #update name of the file that will be updated
                    repoName="$row_repoName"
                    #mark info that found proper
                    repoId=""
                    break;
                fi
            fi
        done < "$repoDir/repolist"        
        #check if didn't found entry
        if [ ! -z "$repoId" ]; then
            #discard changes and print error of untracked repo
            PrintError "Tracked repository at \""$repoPath"\" has repoId \""$row_repoId"\" that has not been marked yet."
            Print "Discarding update."
            RepoCleanChanges
            return
        fi
        repoId="$row_repoId"

        #now we can safely update the config
        Print "Saving local config for $repoName"
        RepoWrite "config/"$repoName"" "$(git -C "$repoPath" config --local --list)"

        #next
    done < "$repoDir/repolist"
    
    #stage update
    RepoStage
}

#================================================================
#region Commands

case "$1" in
    #------------------------------------------------------------
    log)
        cd "$repoDir"
        git log
        ;;
    status)
        cd "$repoDir"
        git status
        ;;
    commit)
        RepoCommit
        ;;
    stage)
        Update
        ;;
    reset)
        cd "$repoDir"
        git reset --hard
        ;;
    #------------------------------------------------------------
    mark)
        if [ -z "$2" ]; then
            #current dir
            Mark "$currentDir"
        else
            #many dirs
            shift
            while [ $# -gt 0 ]; do
                Mark "$1"
                shift
            done
        fi
        ;;
    list)
        List
        ;;
    demark)
        DeMark $2
        ;;
    #------------------------------------------------------------
    export)
        ;;
    import)
        ;;
    #------------------------------------------------------------
    update)
        Update
        #RepoCommit
        ;;
    fetch)
        ;;
    #------------------------------------------------------------
    *)
        Print "No command"
        ;;
esac

#endregion

#================================================================
#region Exit

Exit

#endregion