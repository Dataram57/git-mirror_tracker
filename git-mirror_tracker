#!/usr/bin/env bash
currentDir=$(pwd)
separator=$'\x3B'

#================================================================
#region Functions

Exit(){
    cd "$currentDir"
    exit 0
}

Print(){
    echo -e "\033[0;34mInfo\033[0m: $1"
}

PrintError(){
    echo -e "\033[0;31mError\033[0m: $1"
}

PrintSuccess(){
    echo -e "\033[0;32mSucess\033[0m: $1"
}

PrintWarning(){
    echo -e "\033[0;33mWarning\033[0m: $1"
}

#endregion

#================================================================
#region Repository

#check if repo exists
repoDir="$HOME"/.config/git-mirror_tracker/
if [ ! -d "$repoDir".git  ]; then
    Print "Initializing git-mirror_tracker repository at $repoDir"
    mkdir -p "$repoDir"
    git init "$repoDir"
fi

#----------------------------------------------------------------
#Functions

RepoWrite(){   #fileName #config
    mkdir -p "$(dirname "$repoDir$1")"
    echo "$2" > "$repoDir$1"
}

RepoCleanChanges(){
    cd "$repoDir"
    git restore . && git clean -fd
    cd "$currentDir"
}

RepoCommit(){
    cd "$repoDir"
    #check changes
    if [ -z "$(git status --porcelain)" ]; then
        Print "Repo has no changes"
        return
    else
        Print "Repo has changes"
        git status
    fi
    #commit
    commitCount="$(git rev-list --count HEAD)"
    if [ -z $commitCount ]; then
        commitName="First Commit"
    else
        commitName="Update $commitCount"
    fi
    Print "Commiting \"$commitName\""
    git add *
    git commit -m "$commitName"
}

RepoStage(){
    cd "$repoDir"
    git add *
    PrintSuccess "Changes have been staged."
    cd "$currentDir"
}

GetRepoId(){
    #this should not only limit the result to just 1 line but to all
    git -C "$1" rev-list --max-parents=0 HEAD | tail -n 1
}

#endregion

#================================================================
#region Listing Management

#check if repolist file exists
repoDir="$HOME"/.config/git-mirror_tracker/
if [ ! -f "$repoDir"repolist ]; then
    Print "Creating repolist file"
    touch "$repoDir"repolist
fi

#----------------------------------------------------------------
#Functions

Mark(){ #repoPath
    #repair repolist 
    RepoCleanChanges

    #correct argument
    repoPath="$1"
    if [ -z "$repoPath" ]; then
        repoPath="$currentDir"
    fi
    repoPath="$(realpath "$repoPath")"

    #skip if repoPath is not a dir
    if [ ! -d "$repoPath" ]; then
        return
    fi
    #skip if git doesn't exists
    if [ ! -d "$repoPath/.git" ]; then
        return
    fi

    #get repoID
    repoId=$(GetRepoId "$repoPath")

    #signal
    Print "Checking $repoPath"

    #check if repo with such path and repoId has already been listed
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        #check
        if [ "$repoPath" = "$row_repoPath" ]; then
            if [ "$repoId" = "$row_repoId" ]; then
                Print "Repository named \"$row_repoName\" already tracks "$repoPath" with \""$repoId"\" as repoId."
                return
            fi
        fi
    done < "$repoDir/repolist"

    #insert with proper name
    repoName=""
    while [ -z "$repoName" ]; do
        #get name
        read -p "Name for $repoPath (default: $(basename "$repoPath"))> " repoName
        if [ -z "$repoName" ]; then
            repoName=$(basename "$repoPath")
        fi

        #check if repo with such name has already been listed
        while IFS= read -r line; do
            IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
            #check
            if [ "$repoName" = "$row_repoName" ]; then
                PrintError "Repository named \"$repoName\" already exists"
                repoName=""
                break
            fi
        done < "$repoDir/repolist"
    done

    #Insert new entry
    echo "${repoName}${separator}${repoPath}${separator}${repoId}" >> "$repoDir/repolist"
    PrintSuccess "Tracking \"$repoName\" at $repoPath."

    #stage repolist
    RepoStage
}

DeMark(){ #RepoName
    #clean changes
    RepoCleanChanges

    #check if repo with such path and repoId has already been listed
    i=$((1))
    f=""
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        #check
        if [ "$1" = "$row_repoName" ]; then
            f=$((i))
            break
        fi
        i=$((i+1))
    done < "$repoDir/repolist"

    #remove if found
    if [ ! -z "$f" ]; then
        #remove line and stage
        sed -i ""$f"d" "$repoDir/repolist"
        PrintSuccess "Demarked \""$1"\"."
        RepoStage
    else
        PrintError "No such repository marked as \""$1"\""
    fi
}

List(){
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        echo -e "\033[0;32m"$row_repoName"\033[0m - $row_repoPath"
    done < "$repoDir/repolist"
}

Update(){
    #Clean untracked mess
    RepoCleanChanges

    #visit each marked repo
    #this method will perform overwrites if there are more than 1 same row_repoPaths.
    while IFS= read -r line; do
        IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
        #get repo vars
        repoName="$row_repoName" 
        repoPath="$row_repoPath"
        #check if there is no git repo at repoPath
        if [ ! -d "$repoPath/.git" ]; then
            continue
        fi
        repoId=$(GetRepoId "$repoPath")
        #repo_* vars will now chagne

        #check if there exists an entry that has the same repoPath and repoId
        while IFS= read -r line; do
            IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
            #check if found the same case
            if [ "$repoPath" = "$row_repoPath" ]; then
                if [ "$repoId" = "$row_repoId" ]; then
                    #update name of the file that will be updated
                    repoName="$row_repoName"
                    #mark info that found proper
                    repoId=""
                    break;
                fi
            fi
        done < "$repoDir/repolist"        
        #check if didn't found entry
        if [ ! -z "$repoId" ]; then
            #discard changes and print error of untracked repo
            PrintError "Tracked repository at \""$repoPath"\" has repoId \""$row_repoId"\" that has not been marked yet."
            Print "Discarding update."
            RepoCleanChanges
            return
        fi
        repoId="$row_repoId"

        #now we can safely update the config
        Print "Saving local config for $repoName"
        RepoWrite "config/"$repoName"" "$(git -C "$repoPath" config --local --list)"

        #next
    done < "$repoDir/repolist"
    
    #stage update
    RepoStage
}

#endregion

#================================================================
#region Remote Server Actions

Sync(){ #repoName   #repoPath
    #Clean untracked mess
    RepoCleanChanges

    #Get repo index
    count=$((1))
    repoIndex=""
    while IFS= read -r line; do
        IFS="$separator" read -r repoName old_repoPath repoId <<< "$line"
        #check
        if [ "$1" = "$repoName" ]; then
            repoIndex=$((count))
            break
        fi
        count=$((count+1))
    done < "$repoDir/repolist"
    if [ -z "$repoIndex" ]; then
        #remove line and stage
        PrintError "No such repository marked as \""$1"\""
        return
    fi

    #correct repoPath (will update repoList)
    repoPath="$old_repoPath"
    if [ ! -z "$2" ]; then
        repoPath="$(realpath "$2")"
    fi

    #check if repository already exists
    if [ -d "$repoPath" ]; then
        #check if dir has a repo
        if [ -d "$repoPath/.git" ]; then
            #no cloning is needed
            #check what kind of repo is this
            if [ "$repoId" = $(GetRepoId "$repoPath") ]; then
                #info
                PrintSuccess "Repository \""$repoName"\" is already cloned."
                #check if repoPath needs to be changed
                if [ "$repoPath" = "$old_repoPath" ]; then
                    Print "No changes are needed."
                else
                    #Update only the repoPath in the repolist
                    Print "Updating the repoPath."
                    #remove old line
                    sed -i ""$repoIndex"d" "$repoDir/repolist"
                    #insert new entry
                    echo "${repoName}${separator}${repoPath}${separator}${repoId}" >> "$repoDir/repolist"

                    #stage and return
                    RepoStage
                fi
                return
            else
                #Can't clone into repo that has a different repo id
                PrintError "Directory "$repoPath" is already occupied by a different repository with a different repoId."
                return
            fi
            #check if dir is not empty
        elif [ ! -z "$(ls -A "$repoPath")" ]; then
            PrintError "Directory "$repoPath" is not empty."
            return
        fi
    fi
    
    #check if local config exists
    if [ ! -f ""$repoDir"config/"$repoName"" ]; then
        PrintError "Repository \"$repoName\" has no local config saved."
        return
    fi

    #get remotes
    remotes=()
    urls=()
    while IFS= read -r line; do
        #filter
        [[ $line == remote.*.url=* ]] || continue
        #get values
        remote=${line#remote.}
        remote=${remote%%.*}
        url=${line#*=}
        #add elements
        remotes+=("$remote")
        urls+=("$url")
    done < "$repoDir/config/$repoName"
    
    #select remote
    selectedUrl=""
    if [ "${#remotes[@]}" = "0" ]; then
        #error
        PrintError "Repository \"$repoName\" has no local remotes to clone from."
        return
    elif [ "${#remotes[@]}" = "1" ]; then
        Print "Selecting the only remote (${remotes[$selectedUrl]})."
        #default select
        selectedUrl=0
    else
        #Select remote
        echo "Select remote repository to clone from"
        for i in "${!remotes[@]}"; do
            echo -e "\033[0;35m${remotes[$i]}\033[0m) ${urls[$i]}"
        done
        
        #selection loop
        selectedUrl=""
        while true; do
            read -p "> " selectedUrl
            found=false
            for i in "${!remotes[@]}"; do
                if [[ "${remotes[$i]}" == "$selectedUrl" ]]; then
                    selectedUrl="$i"
                    found=true
                    break
                fi
            done
            $found && break
            PrintError "Invalid selection, try again."
        done
    fi

    #clone repo to a temporary directory
    Print "Cloning from [${remotes[$selectedUrl]}](${urls[$selectedUrl]})"
    rm -rf ""$repoDir"temp"
    git clone "${urls[$selectedUrl]}" ""$repoDir"temp"

    #remember old repo name
    old_repoName="$repoName"

    #check cloned repo's repoId
    new_repoId=$(GetRepoId ""$repoDir"temp")

    #default actions
    doApplyConfig=true

    #compare ids
    if [ "$repoId" = "$new_repoId" ]; then
        PrintSuccess "Cloned repository matches expected repoId."
        Print "Updating repoPath."
        #remove old line
        sed -i ""$repoIndex"d" "$repoDir/repolist"
        #insert new entry
        echo "${repoName}${separator}${repoPath}${separator}${repoId}" >> "$repoDir/repolist"
    else
        #mark a new repo completely
        PrintWarning "Remote [${remotes[$selectedUrl]}](${urls[$selectedUrl]}) seem to be using different repoId than expected."
        Print "Attempting to mark this repository as new."

        #update repoId
        repoId="$new_repoId"

        #mark as new
        echo -e "\033[0;35mDo you want to mark this repository as new?\033[0m (type \033[0;35myes\033[0m for yes)"
        read -p "> " doApplyConfig
        if [ "$doApplyConfig" = 'yes' ]; then
            #name picking procedure
            repoName=""
            while [ -z "$repoName" ]; do
                #get name
                read -p "Repository name> " repoName

                #check if repo with such name has already been listed
                while IFS= read -r line; do
                    IFS="$separator" read -r row_repoName row_repoPath row_repoId <<< "$line"
                    #check
                    if [ "$repoName" = "$row_repoName" ]; then
                        PrintError "Repository named \"$repoName\" already exists"
                        repoName=""
                        break
                    fi
                done < "$repoDir/repolist"
            done

            #Insert new entry
            echo "${repoName}${separator}${repoPath}${separator}${repoId}" >> "$repoDir/repolist"
            PrintSuccess "Tracking \"$repoName\" at $repoPath."
            PrintWarning "It's recommended to run \`update\` command after marking a new repository."
        fi 

        #apply config check
        echo -e "\033[0;35mDo you want apply the existing config?\033[0m (type \033[0;35myes\033[0m for yes)"
        read -p "> " doApplyConfig
        if [ "$doApplyConfig" = 'yes' ]; then
            doApplyConfig=true
        else
            doApplyConfig=false
        fi
    fi;

    #applying local config
    if [[ $doApplyConfig == true ]]; then
        Print "Applying local config."
        cd ""$repoDir"temp"
        while IFS= read -r line; do
            IFS="=" read -r param_name param_value <<< "$line"
            git config --local "$param_name" "$param_value"
        done < "$repoDir/config/$old_repoName"
        git config --local --list
    fi

    #move temp repo to proper path
    Print "Moving new repo to "$repoPath""
    mv ""$repoDir"temp" "$repoPath"

    #stage
    RepoStage
}

#

# - Audits specific repository sources
# - no repository cloning, but simple queries
# - `git rev-list --left-right --count origin/main...main`
# - `git ls-remote origin`
# - `git show-ref`
Audit(){
    #clean logs
    rm "$repoDir/audit_logs"

    #best audit is performed on currently holded repositories as they hold commitments
    #check all existing repos
    while IFS= read -r line; do
        IFS="$separator" read -r repoName repoPath repoId <<< "$line"
        
        #load saved local config
        if [ ! -f "$repoDir/config/$repoName" ]; then
            PrintError "Repository \"$repoName\" has no local config saved."
            continue
        fi

        #audit option vars
        allow_clone=false
        allow_lsremote=true                
        allow_fetch=false

        #check repoId
        check_repoId=""
        if [ -d "$repoPath" ]; then
            if [ -d "$repoPath/.git" ]; then
                check_repoId=$(GetRepoId "$repoPath")
            fi
        fi
        #check need for cloning
        if [ ! "$check_repoId" = "$repoId" ]; then
            if [[ $allow_clone == true ]]; then
                #clone and check again
                PrintError "Couldn't perform \`git clone\` for \""$repoName"\""
                continue
            else
                #error if fetch is required
                if [[ $allow_fetch == true ]]; then
                    PrintWarning "Can't perform fetches on \"$repoName\"."
                    allow_fetch=false
                fi
            fi
        fi

        #logs
        printf "\n================================================================" >> "$repoDir/audit_logs"

        #stats
        countSuccess=0
        countAll=0

        if [[ $allow_fetch == true ]]; then
            Print "Full audit for repository \"$repoName\""
            # -------------------------------
            # Fetch each remote from config and report failures
            # -------------------------------

            while IFS= read -r line; do
                [[ $line == remote.*.url=* ]] || continue

                countAll=$((countAll + 1))
                remote=${line#remote.}
                remote=${remote%%.*}
                url=${line#*=}

                printf "\n\n$repoName.$remote) Running \`git fetch $remote\`\n" >> "$repoDir/audit_logs"

                if git -C "$repoPath" fetch "$remote" >/dev/null 2>&1; then
                    #PrintSuccess "Remote \"$remote\" responded successfully."
                    countSuccess=$((countSuccess + 1))
                else
                    PrintWarning "Remote \"$remote\" from repository \"$repoName\" failed to respond."
                fi
            done < "$repoDir/config/$repoName"

        elif [[ $allow_lsremote == true ]]; then
            #check if repo exists locally
            if [ -d "$repoPath" ]; then
                Print "Quick audit for repository \"$repoName\""
                #load config and query remotes
                while IFS= read -r line; do
                    #filter
                    [[ $line == remote.*.url=* ]] || continue
                    #count
                    countAll=$((countAll + 1))
                    #get values
                    remote=${line#remote.}
                    remote=${remote%%.*}
                    url=${line#*=}

                    #logs
                    printf "\n\n$repoName.$remote) Running \`git ls-remote "$url"\`:\n" >> "$repoDir/audit_logs"
            
                    #query
                    output=$(git ls-remote "$url")
                    if [ $? -ne 0 ]; then
                        PrintError "Remote \"$remote\" of repository \"$repoName\", failed to respond correctly."
                    else
                        countSuccess=$((countSuccess + 1))
                    fi

                    #verify if commit hash exist in local repo $repoPath
                    # verify if commit hash exists in local repo $repoPath
                    while IFS= read -r remoteLine; do
                        # extract hash from remote line
                        commitHash=$(echo "$remoteLine" | awk '{print $1}')
                        
                        # check if commit exists locally
                        if git -C "$repoPath" cat-file -e "$commitHash" 2>/dev/null; then
                            printf "Commit %s from remote %s exists locally.\n" "$commitHash" "$remote" >> "$repoDir/audit_logs"
                        else
                            PrintError "Commit $commitHash from remote \"$remote\" of repository \"$repoName\" does NOT exist locally."
                        fi
                    done <<< "$output"

                    
                done < "$repoDir/config/$repoName"
            else
                Print "Response audit for repository \"$repoName\"."

                #load config and query remotes
                while IFS= read -r line; do
                    #filter
                    [[ $line == remote.*.url=* ]] || continue
                    #count
                    countAll=$((countAll + 1))
                    #get values
                    remote=${line#remote.}
                    remote=${remote%%.*}
                    url=${line#*=}
                    
                    #logs
                    printf "\n\n$repoName.$remote) Running \`git ls-remote "$url"\`:\n" >> "$repoDir/audit_logs"
            
                    #query
                    output=$(git ls-remote "$url")
                    if [ $? -ne 0 ]; then
                        PrintError "Remote \"$remote\" of repository \"$repoName\", failed to respond correctly."
                    else
                        countSuccess=$((countSuccess + 1))
                    fi

                    #logs
                    printf "$output" >> "$repoDir/audit_logs"

                done < "$repoDir/config/$repoName"
            fi
        else
            PrintError "No audit for repository \"$repoName\""
            continue
        fi

        #print stats
        if [ "$countAll" -eq "$countSuccess" ]; then
            PrintSuccess "All remotes of repository \"$repoName\" have all local commits."
        elif [ "$countSuccess" -eq 0 ]; then
            PrintError "All remotes of repository \"$repoName\" don't have all local commits"
        else
            PrintWarning "Only $countSuccess/$countAll of repository \"$repoName\" remotes have all local commits."
        fi
        
        #next
    done < "$repoDir/repolist"
}

#endregion

#================================================================
#region Commands

case "$1" in
    #------------------------------------------------------------
    #region Repository

    history)
        cd "$repoDir"
        git log
        ;;
    
    status)
        cd "$repoDir"
        git status
        ;;
    
    commit)
        RepoCommit
        ;;

    #endregion

    #------------------------------------------------------------
    #region Listing Management

    mark)
        if [ -z "$2" ]; then
            #current dir
            Mark "$currentDir"
        else
            #many dirs
            shift
            while [ $# -gt 0 ]; do
                Mark "$1"
                shift
            done
        fi
        ;;
    
    demark)
        DeMark $2
        ;;
    
    list)
        List
        ;;
    
    update)
        Update
        ;;

    #endregion

    #------------------------------------------------------------
    #region Remote Server Actions

    sync)
        Sync $2 $3
        ;;

    audit)
        Audit $2
        ;;
    
    logs)
        less "$repoDir/audit_logs" 
        ;;

    #endregion

    #------------------------------------------------------------
    export)
        ;;
    import)
        ;;
    #------------------------------------------------------------
    fetch)
        ;;
    #------------------------------------------------------------
    *)
        Print "No command"
        ;;
esac

#endregion

#================================================================
#region Exit

Exit

#endregion